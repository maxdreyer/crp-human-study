"""Tools for generating and uploading qualification tests.

The qualification tests generated by these functions consist
of a title, some instructions, and a sequence of questions in
which users are shown one or more images and must pick an answer.
"""
import dataclasses
import pathlib
from typing import Sequence
from urllib import request

import yaml
from tqdm.auto import tqdm

QUESTION_FORM_XMLNS = (
    'http://mechanicalturk.amazonaws.com/'
    'AWSMechanicalTurkDataSchemas/2017-11-06/QuestionForm.xsd')
ANSWER_KEY_XMLNS = ('http://mechanicalturk.amazonaws.com/'
                    'AWSMechanicalTurkDataSchemas/2005-10-01/AnswerKey.xsd')


@dataclasses.dataclass(frozen=True)
class Question:
    """A qualification question."""

    question_id: str
    image_urls: Sequence[str]
    options: Sequence[str]
    answer_index: int


@dataclasses.dataclass(frozen=True)
class Config:
    """A qualification test."""

    title: str
    instructions: str
    questions: Sequence[Question]


def parse_yaml_config(yaml_file: pathlib.Path,
                      validate_urls: bool = True,
                      display_progress: bool = True) -> Config:
    """Parse questions from a YAML file.

    The format of file is as follows:

        title: My Qualification Config
        instructions: Please answer all of the questions.
        questions:
            - id: q1
              image_urls:
                - https://images.com/my_image_1.png
                - https://images.com/my_image_2.png
              options:
                - answer option 1
                - answer option 2
              answer_index: 0
            - id: q2
              image_urls:
                - https://images.com/my_image_3.png
                - https://images.com/my_image_4.png
              options:
                - answer option 3
                - answer option 4
              answer_index: 1

    Args:
        yaml_file (pathlib.Path): Path to YAML config file.
        validate_urls (bool, optional): If set, make sure all image URLs
            actually open.
        display_progress (bool, optional): If set, show progress bar while
            loading configs.

    Raises:
        ValueError: If config is incorrectly formatted.

    Returns:
        Config: Parsed test configuration.

    """
    with yaml_file.open('r') as config_file:
        config = yaml.safe_load(config_file)

    title = config.get('title')
    if title is None or not isinstance(title, str):
        raise ValueError('"title" is required as str')

    instructions = config.get('instructions')
    if instructions is None or not isinstance(instructions, str):
        raise ValueError('"instructions" is required as str')

    question_configs = config.get('questions')
    if not question_configs or not isinstance(question_configs, list):
        raise ValueError('must add >= 1 questions in list')

    question_configs = question_configs or []
    if display_progress:
        question_configs = tqdm(question_configs, desc='validate questions')

    questions = []
    for question_config in question_configs:
        question_id = question_config.get('id')
        if question_id is None or not isinstance(question_id, str):
            raise ValueError('question "id" required as str')

        image_urls = question_config.get('image_urls')
        if image_urls is None or not isinstance(image_urls, list):
            raise ValueError('question "image_urls" required as list')
        if len(image_urls) < 1:
            raise ValueError('must provide >= 1 image_urls')
        for index, image_url in enumerate(image_urls):
            if not isinstance(image_url, str):
                raise ValueError(f'image_urls item {index} must be str')
            if validate_urls:
                code = request.urlopen(image_url).getcode()
                if code != 200:
                    raise ValueError(f'bad url (code {code}): {image_url}')

        options = question_config.get('options')
        if options is None or not isinstance(options, list):
            raise ValueError('question "options" required as list')
        if len(options) < 2:
            raise ValueError('must provide >= 2 answer options')
        for index, option in enumerate(options):
            if not isinstance(option, str):
                raise ValueError(f'options item {index} must be str')

        answer_index = question_config.get('answer_index')
        if answer_index is None or not isinstance(answer_index, int):
            raise ValueError('question "answer_index" required as int')
        if answer_index < 0 or answer_index >= len(options):
            raise ValueError(f'answer_index {answer_index} out of bounds '
                             f'given there are {len(options)} answer options')

        questions.append(
            Question(question_id=question_id,
                     image_urls=tuple(image_urls),
                     options=tuple(options),
                     answer_index=answer_index))

    return Config(title=title,
                  instructions=instructions,
                  questions=tuple(questions))


def generate_questions_xml(test: Config) -> str:
    """Generate questions XML according to MTurk schema.

    Args:
        test (Config): The test configuration.

    Returns:
        str: Questions XML as a string.

    """
    questions_xml_lines = [
        f'<QuestionForm xmlns="{QUESTION_FORM_XMLNS}">',
        '<Overview>',
        '<Title>',
        test.title,
        '</Title>',
        '<Text>',
        test.instructions,
        '</Text>',
        '</Overview>',
    ]
    for question_index, question in enumerate(test.questions):
        questions_xml_lines.append('<Question>')

        questions_xml_lines.append('<QuestionIdentifier>')
        questions_xml_lines.append(question.question_id)
        questions_xml_lines.append('</QuestionIdentifier>')

        questions_xml_lines.append('<DisplayName>')
        questions_xml_lines.append(f'Question {question_index + 1}')
        questions_xml_lines.append('</DisplayName>')

        questions_xml_lines.append('<IsRequired>true</IsRequired>')

        questions_xml_lines.append('<QuestionContent>')
        questions_xml_lines.append('<FormattedContent><![CDATA[')
        questions_xml_lines.append('<table><tr>')
        for image_index, image_url in enumerate(question.image_urls):
            questions_xml_lines.append(
                '<td>'
                f'<img src="{image_url}" alt="image {image_index + 1}"/>'
                '</td>')
        questions_xml_lines.append('</tr></table>')
        questions_xml_lines.append(']]></FormattedContent>')
        questions_xml_lines.append('</QuestionContent>')

        questions_xml_lines.append('<AnswerSpecification>')
        questions_xml_lines.append('<SelectionAnswer>')
        questions_xml_lines.append('<Selections>')
        for option in question.options:
            questions_xml_lines.append('<Selection>')
            questions_xml_lines.append('<SelectionIdentifier>')
            questions_xml_lines.append(option.replace(' ', '_'))
            questions_xml_lines.append('</SelectionIdentifier>')
            questions_xml_lines.append('<Text>')
            questions_xml_lines.append(option)
            questions_xml_lines.append('</Text>')
            questions_xml_lines.append('</Selection>')
        questions_xml_lines.append('</Selections>')
        questions_xml_lines.append('</SelectionAnswer>')
        questions_xml_lines.append('</AnswerSpecification>')

        questions_xml_lines.append('</Question>')
    questions_xml_lines.append('</QuestionForm>')
    return '\n'.join(questions_xml_lines)


def generate_answers_xml(test: Config) -> str:
    """Generate answer key XML according to MTurk schema.

    Args:
        test (Config): The test configuration.

    Returns:
        str: Answer key XML as string.

    """
    answers_xml_lines = [
        f'<AnswerKey xmlns="{ANSWER_KEY_XMLNS}">',
    ]
    for question in test.questions:
        answers_xml_lines.append('<Question>')
        answers_xml_lines.append('<QuestionIdentifier>')
        answers_xml_lines.append(question.question_id)
        answers_xml_lines.append('</QuestionIdentifier>')
        answers_xml_lines.append('<AnswerOption>')
        answers_xml_lines.append('<SelectionIdentifier>')
        answers_xml_lines.append(
            question.options[question.answer_index].replace(' ', '_'))
        answers_xml_lines.append('</SelectionIdentifier>')
        answers_xml_lines.append('<AnswerScore>1</AnswerScore>')
        answers_xml_lines.append('</AnswerOption>')
        answers_xml_lines.append('</Question>')
    answers_xml_lines.append('<QualificationValueMapping>')
    answers_xml_lines.append('<PercentageMapping>')
    answers_xml_lines.append(
        f'<MaximumSummedScore>{len(test.questions)}</MaximumSummedScore>')
    answers_xml_lines.append('</PercentageMapping>')
    answers_xml_lines.append('</QualificationValueMapping>')
    answers_xml_lines.append('</AnswerKey>')
    return '\n'.join(answers_xml_lines)


def generate_mockup_html(test: Config) -> str:
    """Generate an HTML mockup of the test.

    Args:
        test (Config): The test configuration.

    Returns:
        str: HTML mockup as a string.

    """
    html_lines = [
        '<!DOCTYPE html>',
        '<html>',
        '<body>',
        f'<h2>{test.title}</h2>',
        f'<p>{test.instructions}</p>',
    ]
    for question_index, question in enumerate(test.questions):
        html_lines.append(f'<h3>Question {question_index + 1}</h3>')
        html_lines.append('<table>')
        html_lines.append('<tr>')
        for image_url in question.image_urls:
            html_lines.append(f'<td><img src="{image_url}"/></td>')
        html_lines.append('</tr>')
        html_lines.append('</table>')

        html_lines.append('<ol type="A">')
        for option in question.options:
            html_lines.append('<li>')
            html_lines.append(f'{option} (id {option.replace(" ", "_")})')
            html_lines.append('</li>')
        html_lines.append('</ol>')
    html_lines.append('</body>')
    html_lines.append('</html>')
    return '\n'.join(html_lines)
